<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realized Price Data Plot</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
        }
        h1, h2 {
            text-align: center;
        }
        #myChart {
            background-color: black;
        }
    </style>
</head>
<body>
    <h1>Realized Price and BTC Close Price Data</h1>
    <div style="width: 80%; margin: auto;">
        <canvas id="myChart"></canvas>
    </div>

    <h2>Rolling Window Size for Z-Score Calculation</h2>
    <div style="text-align: center;">
        <input type="number" id="windowSize" value="30" min="1" step="1">
        <button onclick="updateChart()">Update Chart</button>
    </div>

    <script>
        const csvUrl = 'https://raw.githubusercontent.com/taniosHWMF/SDCA/main/BTC%20Close%20Price%20&%20RealizedPriceSTH.csv';

        let labels, btcClosePrice, realizedPriceSTH;

        fetch(csvUrl)
            .then(response => response.text())
            .then(csvData => {
                const rows = csvData.split('\n').map(row => row.split(','));
                labels = rows.slice(1).map(row => row[0]);
                btcClosePrice = rows.slice(1).map(row => parseFloat(row[1]));
                realizedPriceSTH = rows.slice(1).map(row => parseFloat(row[2]));
                updateChart();
            })
            .catch(error => console.error('Error loading or parsing CSV:', error));

        let myChart = null;

        function updateChart() {
            const windowSize = parseInt(document.getElementById('windowSize').value, 10);
            const zScores = calculateZScores(btcClosePrice, realizedPriceSTH, windowSize);
            const [zMin, zMax] = getZScoreRange(zScores);

            const mainChartData = {
                labels: labels,
                datasets: [
                    {
                        label: 'BTC Close Price',
                        data: btcClosePrice,
                        borderColor: 'rgba(0, 0, 0, 0)',
                        backgroundColor: 'rgba(0, 0, 0, 0)',
                        borderWidth: 1,
                        fill: false,
                        segment: {
                            borderColor: (ctx) => {
                                const index = ctx.p0DataIndex;
                                return getColorBasedOnZScore(zScores[index], zMin, zMax);
                            },
                            borderWidth: 2
                        }
                    },
                    {
                        label: 'Realized PriceSTH',
                        data: realizedPriceSTH,
                        borderColor: 'rgb(75, 192, 192)',
                        fill: false,
                        tension: 0,
                        pointRadius: 0,
                        borderWidth: 1
                    },
                    {
                        label: 'Z-Score (BTC vs. Realized Price)',
                        data: zScores,
                        borderColor: 'rgb(255, 255, 255)',
                        fill: false,
                        tension: 0,
                        pointRadius: 0,
                        borderWidth: 1,
                        yAxisID: 'y2'
                    }
                ]
            };

            if (myChart) {
                myChart.destroy();
            }

            const mainChartConfig = {
                type: 'line',
                data: mainChartData,
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Price'
                            },
                            type: 'logarithmic',
                            position: 'left',
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        },
                        y2: {
                            title: {
                                display: true,
                                text: 'Z-Score'
                            },
                            position: 'right',
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(2);
                                }
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            };

            myChart = new Chart(document.getElementById('myChart'), mainChartConfig);
        }

        function calculateZScores(prices, realizedPrices, windowSize) {
            const zScores = [];
            for (let i = 0; i < prices.length; i++) {
                const startIdx = Math.max(0, i - windowSize + 1);
                const windowSlice = realizedPrices.slice(startIdx, i + 1);
                const mean = windowSlice.reduce((acc, val) => acc + val, 0) / windowSlice.length;
                const stdDev = Math.sqrt(windowSlice.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / windowSlice.length);
                const zScore = (prices[i] - mean) / stdDev;
                zScores.push(zScore);
            }
            return zScores;
        }

        function getZScoreRange(zScores) {
            const zMin = Math.min(...zScores);
            const zMax = Math.max(...zScores);
            return [zMin, zMax];
        }

        function getColorBasedOnZScore(zScore, zMin, zMax) {
            // Normalize Z-scores to the range [0, 1]
            const range = zMax - zMin;
            const normalized = (zScore - zMin) / range;

            let r, g, b;

            // If Z-score is exactly 0, make it white
            if (zScore === 0) {
                r = g = b = 255; // white
            } else if (zScore < 0) {
                // Transition from bright red to dark red for negative Z-scores
                r = Math.floor(255 * (1 - Math.abs(zScore))); // Brighter red for less negative Z-scores
                g = Math.floor(255 * (1 + zScore)); // Darker green for negative Z-scores
                b = 0;  // No blue channel
            } else {
                // Transition from bright green to dark green for positive Z-scores
                r = 0;  // No red for positive Z-scores
                g = Math.floor(255 * normalized); // Brighter green for higher Z-scores
                b = 0;  // No blue channel
            }

            return `rgba(${r}, ${g}, ${b}, 0.8)`; // Apply opacity
        }
    </script>
</body>
</html>
