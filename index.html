<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realized Price Data Plot</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>Realized Price and BTC Close Price Data</h1>
    <div style="width: 80%; margin: auto;">
        <canvas id="myChart"></canvas>
    </div>

    <h2>Rolling Window Size for Z-Score Calculation</h2>
    <input type="number" id="windowSize" value="30" min="1" max="200" step="1">
    <button onclick="updateChart()">Update Chart</button>

    <script>
        // URL to your public CSV file
        const csvUrl = 'https://raw.githubusercontent.com/taniosHWMF/SDCA/main/BTC%20Close%20Price%20&%20RealizedPriceSTH.csv';

        let labels, btcClosePrice, realizedPriceSTH;

        // Fetch the CSV file
        fetch(csvUrl)
            .then(response => response.text()) // Fetch as text
            .then(csvData => {
                // Parse the CSV data into rows and values
                const rows = csvData.split('\n').map(row => row.split(','));

                // Extract dates, BTC close prices, and realized prices
                labels = rows.slice(1).map(row => row[0]); // Dates (first column)
                btcClosePrice = rows.slice(1).map(row => parseFloat(row[1])); // BTC close price (second column)
                realizedPriceSTH = rows.slice(1).map(row => parseFloat(row[2])); // RealizedPriceSTH (third column)

                // Initialize the chart with default window size
                updateChart();
            })
            .catch(error => console.error('Error loading or parsing CSV:', error));

        let myChart = null;

        function updateChart() {
            // Get the rolling window size from user input
            const windowSize = parseInt(document.getElementById('windowSize').value, 10);

            // Calculate Z-scores for the BTC Close Price relative to Realized Price
            const zScores = calculateZScores(btcClosePrice, realizedPriceSTH, windowSize);

            // Color each BTC close price point based on the Z-score with smoother transition
            const btcCloseColors = calculateColorBasedOnZScore(zScores);

            // Data for the main chart (BTC Close Price vs. Realized Price)
            const mainChartData = {
                labels: labels,
                datasets: [
                    {
                        label: 'BTC Close Price',
                        data: btcClosePrice,
                        borderColor: 'rgba(0,0,0,0)', // No line color (points are individually colored)
                        backgroundColor: btcCloseColors, // Color points based on Z-score
                        pointRadius: 3, // Make the points visible
                        borderWidth: 1 // Thinner line (no line visible)
                    },
                    {
                        label: 'Realized PriceSTH',
                        data: realizedPriceSTH,
                        borderColor: 'rgb(75, 192, 192)', // Line color for Realized PriceSTH
                        fill: false, // No fill under the line
                        tension: 0, // Remove smoothing (straight line)
                        pointRadius: 0, // Remove dots at data points
                        borderWidth: 1 // Thinner line
                    },
                    {
                        label: 'Z-Score (BTC vs. Realized Price)',
                        data: zScores,
                        borderColor: 'rgb(0, 0, 0)', // Line color for Z-score (black)
                        fill: false, // No fill under the line
                        tension: 0, // Straight line
                        pointRadius: 0, // No dots
                        borderWidth: 1, // Thinner line
                        yAxisID: 'y2' // Link to secondary y-axis
                    }
                ]
            };

            // Destroy existing chart if it exists
            if (myChart) {
                myChart.destroy();
            }

            // Main chart configuration
            const mainChartConfig = {
                type: 'line', // Line chart
                data: mainChartData,
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Price'
                            },
                            type: 'logarithmic', // Set the y-axis to logarithmic
                            position: 'left',
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString(); // Format numbers with commas
                                }
                            }
                        },
                        y2: {
                            title: {
                                display: true,
                                text: 'Z-Score'
                            },
                            position: 'right', // Secondary axis on the right side
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(2); // Format Z-scores to 2 decimal places
                                }
                            },
                            grid: {
                                drawOnChartArea: false // Don't draw gridlines for secondary axis
                            }
                        }
                    }
                }
            };

            // Create the main chart
            myChart = new Chart(document.getElementById('myChart'), mainChartConfig);
        }

        // Function to calculate Z-scores with a rolling window (inverted Z-score logic)
        function calculateZScores(prices, realizedPrices, windowSize) {
            const zScores = [];
            
            // Start from index 'windowSize - 1' (to ensure the window is filled)
            for (let i = windowSize - 1; i < prices.length; i++) {
                // Get the window slice of the Realized Price
                const windowSlice = realizedPrices.slice(i - windowSize + 1, i + 1);
                
                // Calculate the mean of the window slice
                const mean = windowSlice.reduce((acc, val) => acc + val, 0) / windowSlice.length;

                // Calculate the standard deviation of the window slice
                const stdDev = Math.sqrt(windowSlice.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / windowSlice.length);

                // Calculate Z-score for the corresponding BTC Close Price (inverted logic)
                const zScore = -((prices[i] - mean) / stdDev); // Inverted Z-score logic
                
                // Push the Z-score for this index
                zScores.push(zScore);
            }

            return zScores;
        }

        // Function to calculate color based on Z-score values with smooth transitions
        function calculateColorBasedOnZScore(zScores) {
            return zScores.map(zScore => {
                // Normalize the Z-score for color scale mapping
                const normalizedZScore = Math.max(-3, Math.min(3, zScore)); // Clamping Z-score between -3 and 3

                // Interpolating the color scale from red (-3) to green (+3)
                const r = Math.floor(Math.max(0, 255 * (3 - normalizedZScore) / 6));
                const g = Math.floor(Math.max(0, 255 * (normalizedZScore + 3) / 6));
                const b = 0; // Blue remains 0 for a red-green transition

                // Return the smooth color based on the normalized Z-score
                return `rgba(${r}, ${g}, ${b}, 0.8)`; // Smoother transition with some opacity
            });
        }
    </script>
</body>
</html>
